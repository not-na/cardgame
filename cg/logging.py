#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  logging.py
#  
#  Copyright 2020 contributors of cardgame
#  
#  This file is part of cardgame.
#
#  cardgame is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  cardgame is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with cardgame.  If not, see <http://www.gnu.org/licenses/>.
#


import functools
import logging
import logging.handlers
import os
import platform
import sys
import time
import traceback
from logging import DEBUG, INFO, WARNING, ERROR, CRITICAL
from typing import Callable

import cg

CRASH_TEMPLATE = """
CardGame Crash Report
=================

Crash report generated on {time} by logger '{logger}'

Please submit this report to the official cardgame bugtracker so any potential bugs can be fixed.

Crash Reason: {msg}

{content}
"""

TEMPLATE_SYSINFO = """
System Information:
- sys.platform: {sys.platform}
- sys.flags: {sys.flags}
- sys.version: {sys.version}
"""

TEMPLATE_CGINFO = """
CardGame Information:
- Version: {cg.version.VERSIONSTRING}
- Network Protocol Version: {cg.version.PROTO_VERSION}
"""

TEMPLATE_TRACEBACK = """
Traceback:

{traceback}
"""

TEMPLATE_PLUGINS = """
Plugins:

{plugins}
"""

LOGGER_BLACKLIST = [
    "plumbum.local",
    "plumbum.shell",
    "urllib3",
    "urllib3.poolmanager",
    "urllib3.connectionpool",
    "urllib3.response",
    "urllib3.connection",
    "urllib3.util.retry",
    "requests",
    "past.translation",
    "future_stdlib",
    "chardet.universaldetector",
    "jsonspec.pointer.bases",
    "jsonspec.pointer",
]


class CrashReporter(object):
    """
    This class implements an extendable crash reporting system.

    Extensions work by adding so-called crash categories via :py:meth:`add_category()`\ .
    By default, several useful categories are already included.

    :param CardGame cg: :py:class:`CardGame` singleton
    """
    def __init__(self, cg):
        self.cg = cg

        self.categories = {}
        self.categories_order = []

        self.register_default_categories()

    def register_default_categories(self):
        """
        Registers default crash categories.

        These include ``sysinfo``\ , ``cginfo``\ , ``traceback`` and ``plugins``\ .
        They are implemented in the :py:meth:`cat_*` family of methods.

        :return: None
        """
        self.add_category("sysinfo", self.cat_sysinfo)
        self.add_category("cginfo", self.cat_cginfo)
        self.add_category("traceback", self.cat_traceback)
        #self.add_category("plugins", self.cat_plugins)

    def add_category(self, name: str, callback: Callable, pos: int = -1):
        """
        Adds a crash category.

        The callback function must accept exactly two parameters. The first one is
        ``msg``\ , which contains the crash message passed to :py:meth:`generate_report()`\ .
        The second parameter is ``kwargs``\ , a dictionary that contains all keyword
        arguments passed to :py:meth:`generate_report()`\ .

        :param str name: The name of the category
        :param Callable callback: The function to be called to retrieve the content
        :param int pos: Position amongst other categories. Defaults to the last position.
        :return: None
        """
        self.categories[name] = callback

        if pos == -1:
            self.categories_order.append(name)
        else:
            self.categories_order.insert(pos, name)

    def generate_report(self, msg: str, **kwargs):
        """
        Generates and stores a crash report.

        Crash information is gathered from all crash categories registered via :py:meth:`add_category()`\ .
        Categories that return either an empty string or ``None`` will be ignored.

        Crash reports are saved in the ``crash_reports`` folder below the instance path in files
        named by the format ``crash_report-pid<process id>.txt``\ .

        Some private information, like the home directory and user name are automatically
        "blacked" out by the default crash categories, but no guarantees can be made.

        :param str msg: Crash message to be shown
        :param bool exc: Whether or not an exception has occured, if not, a custom stacktrace is generated
        :param kwargs: Captures all other keyword arguments
        :return:
        """
        content = ""

        # Create all content generated by crash information categories
        for cat in self.categories_order:
            if cat in self.categories_order:
                d = self.categories[cat](msg=msg, kwargs=kwargs)

                if d != "" and d is not None:  # This is to prevent multiple empty lines in case a category does not return anything
                    content += d
                    content += "\n"
            else:
                self.cg.error(f"Could not find crash category '{cat}' in registered categories, ignoring")

        # Wrap it with supporting text and instructions
        data = {
            "content": content,
            "time": time.strftime(self.cg.get_config_option("cg:logging.format.crashtime")),
            "msg": msg,
            "logger": kwargs.get("logger", "unknown"),
        }
        out = CRASH_TEMPLATE.format(**data)

        # Store the crash report in a file
        fname = os.path.join(self.cg.get_instance_path(), "crash_reports", f"crash_report-pid{os.getpid()}.txt")
        if not os.path.exists(os.path.join(self.cg.get_instance_path(), "crash_reports")):
            os.mkdir(os.path.join(self.cg.get_instance_path(), "crash_reports"))
        with open(fname, "w") as f:
            f.write(out)
        self.cg.critical(f"Crash Report saved as {fname}, please check it for details about this crash")

        # Try to close cg as cleanly as possible
        try:
            self.cg.send_event("cg:shutdown", {"reason": "crash", "crashmsg": msg, "report": out})
            sys.stdout.flush()  # Ensures that any log messages are sent to the launcher
        finally:
            sys.exit(1)

    # Default Crash Report Categories

    def cat_sysinfo(self, msg: str, kwargs: dict):
        """
        General system information crash category.

        Currently, basic system information from the :py:mod:`sys` module is included.
        This includes :py:data:`sys.flags`\ , :py:data:`sys.platform` and :py:data:`sys.version`\ .

        This crash category uses neither the crash message nor the keyword arguments passed in.

        :param str msg: Crash Message
        :param kwargs: Keyword Arguments
        :return: Formatted String including system information
        """
        # Shows basic system information like operating system and python version
        return TEMPLATE_SYSINFO.format(sys=sys, os=os, platform=platform)

    def cat_cginfo(self, msg: str, kwargs: dict):
        """
        CardGame-specific information crash category.

        Currently, this includes the version of cg and the network protocol version.

        This crash category uses neither the crash message nor the keyword arguments passed in.

        :param str msg: Crash Message
        :param kwargs: Keyword Arguments
        :return: Formatted String including cg information
        """
        # Shows cg version information
        return TEMPLATE_CGINFO.format(cg=cg)

    def cat_traceback(self, msg: str, kwargs: dict):
        """
        Crash Category reporting either the last exception or the current call stack.

        The ``exc`` keyword argument may be used to define whether the last exception
        or the current call stack shall be shown. It defaults to ``False``\ .
        Within the call trace, the equivalent of the ``~`` symbol will be replaced by ``<HOME>``
        to protect the privace of the user, should they publish the crash report.

        This crash category does not use the crash message.

        :param str msg: Crash Message
        :param kwargs: Keyword Arguments
        :return: Formatted String including a Stack Trace
        """

        if kwargs.get("exc", False):
            # The comment below is because crash reports may contain that line of code at the end of tracebacks.
            # It should hopefully prevent users from thinking the cg engine is at fault,
            # even though a plugin may be causing the issue.
            tb = "".join(traceback.format_stack()).replace(os.path.expanduser("~"), "<HOME>")  # ^^^ ERROR IS NOT HERE, LOOK ABOVE ^^^
        else:
            tb = traceback.format_exc().replace(os.path.expanduser("~"), "<HOME>")

        return TEMPLATE_TRACEBACK.format(traceback=tb)

    def cat_plugins(self, msg: str, kwargs: dict):
        """
        Crash Category reporting a list of currently loaded plugins and their versions.

        This crash category uses neither the crash message nor the keyword arguments passed in.

        :param str msg: Crash Message
        :param kwargs: Keyword Arguments
        :return: Formatted String including a list of plugins
        """
        plugins = "\n".join(
            [f"{p.pluginid} {p.plugindata['version']}"
                for p in self.cg.plugin_manager.get_plugins()]
        )

        return TEMPLATE_PLUGINS.format(plugins=plugins)


class RestartRotateFileHandler(logging.handlers.RotatingFileHandler):
    """
    Special rotating file handler that only rotates on startup, thus keeping one file per run.
    """
    def __init__(self, fname, *args, **kwargs):
        os.makedirs(os.path.dirname(fname), exist_ok=True)
        open(fname, "a").close()  # Create the log file in case it does not exist

        super().__init__(fname, *args, **kwargs)

        # if platform.system() != "Windows":  # For Windows, the rollover generates a permission error
        self.doRollover()                     # (The file is accessed multiple times)

    def shouldRollover(self, record):
        return False


class LauncherLogHandler(logging.StreamHandler):
    """
    Stream handler that outputs to the launcher.

    Currently, this means that all output is simply written to stdout.
    """
    def __init__(self, stream=None):
        if stream == None:
            stream = sys.__stdout__  # To prevent errors in case the output pipe was overridden

        super().__init__(stream)


class CGLogger(logging.Logger):
    """
    Custom logger that should be used for all logging within cg.

    This logger automatically initializes itself with a :py:class:`LauncherLogHandler()`
    and a :py:class:`RestartRotateFileHandler()`\ .

    .. todo::
       Document supported config options
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.module = "cg"

        if self.name in LOGGER_BLACKLIST:
            return  # Ignore loggers on the blacklist

        if cg.c is None:
            raise RuntimeError(f"Could not find CG object while initializing Logger {self.name}")

        self.setLevel(logging.DEBUG)

        self.formatter_file = logging.Formatter(cg.c.get_config_option("cg:logging.format.file"))
        self.handler_file = RestartRotateFileHandler(
            os.path.join(cg.c.get_instance_path(), cg.c.get_config_option("cg:logging.basefilename")),
            backupCount=cg.c.get_config_option("cg:logging.backupcount"),
        )
        self.handler_file.setFormatter(self.formatter_file)
        self.handler_file.setLevel(cg.c.get_config_option("cg:logging.loglevel.file"))
        self.addHandler(self.handler_file)

        self.formatter_launcher = logging.Formatter(cg.c.get_config_option("cg:logging.format.launcher"))
        self.handler_launcher = LauncherLogHandler()
        self.handler_launcher.setFormatter(self.formatter_launcher)
        self.handler_launcher.setLevel(cg.c.get_config_option("cg:logging.loglevel.launcher"))
        self.addHandler(self.handler_launcher)

        self.debug(f"Initialized logger {self.name}")

    def log(self, level: int, msg: str, module=None, *args, **kwargs):
        if module is None:
            module = self.module

        launchertime = time.strftime(cg.c.get_config_option("cg:logging.format.launchertime"))
        filetime = time.strftime(cg.c.get_config_option("cg:logging.format.filetime"))

        super().log(level,
                    msg,
                    extra={
                        "plugin": module,
                        "launchertime": launchertime,
                        "filetime": filetime,
                    },
                    *args, **kwargs
                    )

    def debug(self, msg, *args, **kwargs):
        self.log(DEBUG, msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        self.log(INFO, msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        self.log(WARNING, msg, *args, **kwargs)

    def error(self, msg, *args, **kwargs):
        self.log(ERROR, msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        self.log(CRITICAL, msg, *args, **kwargs)

    def crash(self, msg: str, **kwargs):
        """
        Proxy for :py:meth:`CrashReporter.generate_report()`\ .

        :param str msg: Crash Message
        :param kwargs: Keyword Arguments
        :return: None
        """
        kwargs["logger"] = self.name
        return cg.c.crash_reporter.generate_report(msg, **kwargs)


logging.setLoggerClass(CGLogger)